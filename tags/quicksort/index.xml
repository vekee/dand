<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>quicksort on DUAN DAHAI</title><link>https://www.duandahai.com/tags/quicksort/</link><description>Recent content in quicksort on DUAN DAHAI</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 08 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.duandahai.com/tags/quicksort/index.xml" rel="self" type="application/rss+xml"/><item><title>Two ways of create a quicksort algorithm by Python</title><link>https://www.duandahai.com/posts/en/20211208-algorithm-quicksort/</link><pubDate>Wed, 08 Dec 2021 00:00:00 +0000</pubDate><guid>https://www.duandahai.com/posts/en/20211208-algorithm-quicksort/</guid><description>In a quick sort algorithm, It picks an element as a pivot and partitions the given array around the picked pivot. (For sort by ascending, it moves smaller number to the pivot&amp;rsquo;s left, and moves bigger number to the pivot&amp;rsquo;s right)
I wrote two classic samples by use python.
Always pick the first element as a pivot. Always pick the last element as a pivot. This is a sample for quick sort that start from first value as pivot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # change the position on each number def swapEachOther(arr, leftIndex, rightIndex): tmp = arr[leftIndex] arr[leftIndex] = arr[rightIndex] arr[rightIndex] = tmp print(arr) # quck sort method : start from first number by pivot def sort(arr, startIndex, endIndex): if startIndex &amp;gt;= endIndex: return leftIndex = startIndex rightIndex = endIndex # set the first pivot by first number compareValue = arr[startIndex] while leftIndex &amp;lt; rightIndex: # find the next pivot that was smaller than compareValue from right while leftIndex &amp;lt; rightIndex and arr[rightIndex] &amp;gt; compareValue: rightIndex = rightIndex - 1 # find the next pivot that was bigger than compareValue from left while leftIndex &amp;lt; rightIndex and arr[leftIndex] &amp;lt;= compareValue: leftIndex = leftIndex + 1 # while finding the next pivot, move smaller number to left and move bigger number to right if leftIndex &amp;lt; rightIndex: swapEachOther(arr, leftIndex, rightIndex) # move the pivot to the middle posotion swapEachOther(arr, startIndex, rightIndex) # use the sort method on left half array sort(arr, startIndex, rightIndex - 1) # use the sort method on right half array sort(arr, rightIndex + 1, endIndex) arr = [3, 1, 2, 9, 4, 10, 5, 8, 6, 7] print(arr) sort(arr, 0, len(arr) -1) This is a sample for quick sort that start from last number as pivot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # change the position on each number def swapEachOther(arr, leftIndex, rightIndex): tmp = arr[leftIndex] arr[leftIndex] = arr[rightIndex] arr[rightIndex] = tmp print(arr) # quck sort method : def sort(arr, startIndex, endIndex): if startIndex &amp;gt;= endIndex: return # set the last number as the pivot number pivotIndex = endIndex # set the partitionIndex before the startIndex partitionIndex = startIndex -1 # change the positon when it smaller than pivot number from left for i in range(startIndex, endIndex): if arr[i] &amp;lt;= arr[pivotIndex]: # move the smaller number to the left of bigger number than pivot partitionIndex = partitionIndex + 1 swapEachOther(arr, partitionIndex, i) # get the partitionIndex that will be cut the array in half partitionIndex = partitionIndex + 1 # move the pivot to the middle posotion swapEachOther(arr, partitionIndex, pivotIndex) # use the sort method on left half array sort(arr, startIndex, partitionIndex - 1) # use the sort method on right half array sort(arr, partitionIndex + 1, endIndex) arr = [3, 1, 2, 9, 4, 10, 5, 8, 6, 7] print(arr) sort(arr, 0, len(arr) -1) You can click here(QuickSort1) , here(QuickSort2) to download the source file.</description></item></channel></rss>